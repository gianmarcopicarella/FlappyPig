#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>

U8G2_SSD1327_WS_128X128_2_4W_SW_SPI u8g2(U8G2_R0, 13, 11, 10, 7, 8);

// Obstacle data struct
typedef struct Obstacle { 
  int x, y;
} Obstacle;
// respectively current and last time in milliseconds, score and transition data
int current_time, last_time, score, x_transition; 
// deltatime, pig's y position, and y acceleration
float delta, py, accy; 
// auxiliary buffer
char buffer[15];
// transition flag
bool is_transition;
// obstacle
Obstacle obstacle;

// Game scene object
typedef struct Scene {
  void (*init)();
  void (*draw)();
  void (*update)();
} Scene;

// main scenes used in this game
Scene menu, game, game_over ;
// current scene pointer
Scene * current_scene;

// flag that is true if this is the first draw call
bool first_render;
// flags respectively used to notify a point and a button press event by the user
bool point, last_press;

// pig bitmap
static unsigned char pig_bits[] = {
  0x21, 0x72, 0xb4, 0xfe, 0x7f, 0x3f, 0x22, 0x22 };

// logo bitmap
static unsigned char Flappy_Pig_Logo_bits[] = {
   0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7e, 0x00, 0x00,
   0x00, 0xc0, 0x07, 0xfe, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff,
   0x00, 0xe0, 0x01, 0xf0, 0x1f, 0xff, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0x00, 0xf0, 0x07, 0xf8, 0x5f, 0xff, 0x73, 0x1c, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0x07, 0x00, 0xf0, 0x0f, 0xfa, 0xdf, 0xe7, 0x73, 0x1c,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0xf4, 0x1f, 0x3e, 0xdf, 0xe7,
   0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc3, 0x01, 0xfc, 0x1f, 0x3e,
   0xdf, 0xf7, 0x71, 0x1c, 0x7e, 0x00, 0x00, 0x00, 0xe0, 0xc7, 0x01, 0xf8,
   0x1e, 0xbe, 0xcf, 0xff, 0xe0, 0x0f, 0xc3, 0x38, 0x00, 0x00, 0xc0, 0xc7,
   0x01, 0xf8, 0x3e, 0xfe, 0x87, 0x7f, 0xc0, 0x8f, 0x81, 0x29, 0x00, 0x00,
   0xc0, 0xc7, 0x01, 0xf8, 0x3c, 0xfc, 0x83, 0x3f, 0x00, 0x8e, 0x00, 0x2d,
   0x00, 0x00, 0xc0, 0xc7, 0x03, 0xf8, 0x3e, 0xfc, 0x81, 0x1f, 0x00, 0x4e,
   0x0e, 0x25, 0x00, 0x00, 0xc0, 0xcf, 0x03, 0xf0, 0x7f, 0xfc, 0x80, 0x0f,
   0x00, 0x4e, 0x8a, 0x2d, 0x00, 0x00, 0xc0, 0xcf, 0x03, 0xf0, 0x7f, 0x7c,
   0x80, 0x0f, 0x00, 0x4e, 0x8a, 0x38, 0x00, 0x00, 0xc0, 0x8f, 0xe3, 0xf0,
   0x7f, 0x7c, 0x80, 0x0f, 0x00, 0x4e, 0x8e, 0x00, 0x00, 0x00, 0xc0, 0x8f,
   0xfb, 0xf1, 0x7d, 0x7c, 0x80, 0x0f, 0x00, 0x4f, 0xc0, 0x00, 0xe0, 0x03,
   0xc0, 0x8f, 0xff, 0xf1, 0xfd, 0x7c, 0x80, 0x0f, 0xc0, 0x4f, 0x70, 0x3c,
   0xb8, 0x02, 0xc0, 0x8f, 0xff, 0xf1, 0xf9, 0x7c, 0x80, 0x0f, 0xf0, 0x47,
   0x1c, 0x24, 0x0c, 0x06, 0xc0, 0x8f, 0xff, 0xf1, 0xf9, 0x7c, 0x80, 0x03,
   0xf8, 0x43, 0x04, 0x24, 0xf4, 0x04, 0xc0, 0x8f, 0x3f, 0xf0, 0x79, 0x1c,
   0x00, 0x00, 0xf8, 0x60, 0x04, 0x24, 0x96, 0x04, 0xc0, 0x8f, 0x07, 0x70,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x26, 0xf2, 0x0c, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x22, 0x02, 0x08,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x22,
   0x7e, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x07, 0x3e, 0xc0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0c, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x04,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x0e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xf2, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x1e, 0x00 };

// change scene invoking init method
void change_scene(Scene * s){
  current_scene = s;
  current_scene->init();
}

// init menu
void init_menu(){
  x_transition = 50, py = 80;
  is_transition = false, first_render = true;
}

// init game
void init_game(){
  py = 60, accy = 0, score = 0;
  point = false, last_press = false;
  u8g2.setFont(u8g2_font_6x12_tr);
  obstacle = {128, 35 + rand()%50};
}

// init game over
void init_game_over(){
  first_render = true;
}

void update_menu(){
  static float angle = 0.f;
  // if game button is pressed then start transitioning
  if(digitalRead(2) == HIGH) is_transition = true;
  
  // once the transition is finished change scene
  if(is_transition && x_transition <= 10) {
    change_scene(&game);
    return;
  }
  // otherwise continue transitioning
  else if(is_transition){
    x_transition -= 5 * delta;
  }

  // pig vertical movement
  py += sin(angle) * 20.f * delta;
  angle += 0.5f;
  if(angle == 360.f) angle = 0.f;
}

void draw_menu(){
  if(first_render) {
    first_render = false;
    u8g2.firstPage();
    do {
      u8g2.drawXBM(10, 0, 108, 39, Flappy_Pig_Logo_bits);
      u8g2.setFont(u8g2_font_6x12_tr);
      u8g2.drawStr(18,50,"Press to start");
    } while(u8g2.nextPage());
  }
  else {
    u8g2.customPage(7);
    do {
      u8g2.drawXBM(x_transition, py, 8, 8, pig_bits);
    } while(u8g2.nextPage());
  }
}

void update_game(){
  // if there is a collision then change scene to GameOver
  if(py > 127 || py < 0 || (18 > obstacle.x && 10 < obstacle.x + 10 && (py <  obstacle.y - 24 || py+8 > obstacle.y + 24))){
    change_scene(&game_over);
    return;
  }
  // increase score and play the sound
  if(10 > obstacle.x + 5 && !point){
    point = true;
    score++;
    tone(9,1500,200);
  }
  // increase vertical acceleration
  accy += 100.f * delta;

  // if the game button is pressed then jump
  int dr = digitalRead(2);
  if (!last_press && dr == HIGH) {
    last_press = true;
    accy = -45.f;
  }
  else if(last_press && dr == LOW) {
    last_press = false;
  }

  // change pig's y position
  py += accy * delta;
  if(obstacle.x + 5 <= 0){
    obstacle = {128, 35 + rand()%50 };
    point = false;
  }
  // horizontally move obstacle based on potentiometer value
  obstacle.x -= map(analogRead(A0), 0, 1023, 1, 3) * 15.f * delta;
}

void draw_game(){
  u8g2.firstPage();
  do {
    sprintf(buffer, "%d", score);
    u8g2.drawStr(2,10,buffer);
    u8g2.drawXBM(10, py, 8, 8, pig_bits);
    u8g2.drawFrame(obstacle.x, -1, 10, obstacle.y - 25);
    u8g2.drawFrame(obstacle.x, obstacle.y + 25, 10, 128);
  } while ( u8g2.nextPage() );
}

void update_game_over(){
  // if the game button is pressed then start a new game
  if(digitalRead(2) == HIGH){
    change_scene(&game);
  }
}

void draw_game_over(){
  if(first_render){
    first_render = false;
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_ncenB14_tr);
      u8g2.drawStr(10,24,"Game Over!");
      sprintf(buffer, "Score: %d", score);
      u8g2.drawStr(10,44, buffer);
      u8g2.setFont(u8g2_font_6x12_tr);
      u8g2.drawStr(10,64,"Premi il pulsante");
      u8g2.drawStr(10,74,"per ricominciare");
    } while ( u8g2.nextPage() );
    // run "game over" song
    tone(9,500,200);
    delay(200);
    tone(9,400,200);
    delay(200);
    tone(9,200,600);
    delay(600);
  }
}

void setup(void) {
  u8g2.begin();
  
  pinMode(2, INPUT);
  pinMode(4, INPUT);
  pinMode(9, OUTPUT);
  pinMode(A0, INPUT);

  current_time = 0, last_time = 0;
  delta = 0;

  menu = { &init_menu, &update_menu, &draw_menu };
  game_over = { &init_game_over, &update_game_over, &draw_game_over };
  game = { &init_game, &update_game, &draw_game };
  change_scene(&menu);
}
void loop(void) {
  static float timer = 0;
  
  last_time = current_time;
  current_time = millis();
  delta = (current_time - last_time) / 1000.f;

  current_scene->update();
  if(timer > 0.0625f){
    timer = 0;
    current_scene->draw();
  }
  timer += delta;
}
